{
  "hash": "8a469b49d8511d95244a3cbcc121afe7",
  "result": {
    "markdown": "---\ntitle: \"03 - Confidence Intervals\"\n---\n\n\nMini Project 3: Confidence Intervals\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\nn = 5000\np = .5\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5000   # sample size\np <- 0.5  # population proportion\nalpha <- .1\n\ngenerate_samp_prop <- function(n,p){\n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  \n  #create lower and upper bound with 90% CI\n   lb <- phat - 1.645 *sqrt(phat*(1-phat)/n)\n   ub <- phat + 1.645 *sqrt(phat*(1-phat)/n)\n  \n\n  prop_df <- tibble(phat,lb,ub)\n  return(prop_df)\n}\n\ngenerate_samp_prop(n,p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1 0.501 0.489 0.513\n```\n:::\n\n```{.r .cell-code}\n#How many CI's we want\nn_sim <- 1000\n\nprop_ci_df <- map(1:n_sim, \\(i) generate_samp_prop(n,p)) |> \n  bind_rows()\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 3\n    phat    lb    ub\n   <dbl> <dbl> <dbl>\n 1 0.499 0.487 0.511\n 2 0.500 0.488 0.511\n 3 0.504 0.492 0.515\n 4 0.492 0.480 0.504\n 5 0.511 0.499 0.523\n 6 0.514 0.503 0.526\n 7 0.510 0.498 0.521\n 8 0.503 0.491 0.515\n 9 0.498 0.487 0.510\n10 0.499 0.488 0.511\n# ℹ 990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1    0.0233         0.905\n```\n:::\n:::\n\n\n\n\nn = 100\np=.5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100   # sample size\np <- 0.5  # population proportion\nalpha <- .1\n\ngenerate_samp_prop <- function(n,p){\n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  \n  #create lower and upper bound with 90% CI\n  lb <- phat - 1.645 *sqrt(phat*(1-phat)/n)\n  ub <- phat + 1.645 *sqrt(phat*(1-phat)/n)\n  \n  prop_df <- tibble(phat,lb,ub)\n  return(prop_df)\n}\n\ngenerate_samp_prop(n,p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1   0.5 0.418 0.582\n```\n:::\n\n```{.r .cell-code}\n#How many CI's we want\nn_sim <- 1000\n\nprop_ci_df <- map(1:n_sim, \\(i) generate_samp_prop(n,p)) |> \n  bind_rows()\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 3\n    phat    lb    ub\n   <dbl> <dbl> <dbl>\n 1  0.56 0.478 0.642\n 2  0.52 0.438 0.602\n 3  0.49 0.408 0.572\n 4  0.48 0.398 0.562\n 5  0.5  0.418 0.582\n 6  0.46 0.378 0.542\n 7  0.5  0.418 0.582\n 8  0.59 0.509 0.671\n 9  0.5  0.418 0.582\n10  0.55 0.468 0.632\n# ℹ 990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.164         0.901\n```\n:::\n:::\n\n\n\nn = 5\np = .5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5   # sample size\np <- 0.5  # population proportion\nalpha <- .1\n\ngenerate_samp_prop <- function(n,p){\n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  \n  #create lower and upper bound with 90% CI\n   lb <- phat - 1.645 *sqrt(phat*(1-phat)/n)\n   ub <- phat + 1.645 *sqrt(phat*(1-phat)/n)\n  \n  prop_df <- tibble(phat,lb,ub)\n  return(prop_df)\n}\n\ngenerate_samp_prop(n,p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1   0.6 0.240 0.960\n```\n:::\n\n```{.r .cell-code}\n#How many CI's we want\nn_sim <- 1000\n\nprop_ci_df <- map(1:n_sim, \\(i) generate_samp_prop(n,p)) |> \n  bind_rows()\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 3\n    phat     lb    ub\n   <dbl>  <dbl> <dbl>\n 1   0.6 0.240  0.960\n 2   0.8 0.506  1.09 \n 3   0.8 0.506  1.09 \n 4   0.6 0.240  0.960\n 5   0.4 0.0396 0.760\n 6   0.8 0.506  1.09 \n 7   0.6 0.240  0.960\n 8   0.8 0.506  1.09 \n 9   0.6 0.240  0.960\n10   0.4 0.0396 0.760\n# ℹ 990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.630         0.603\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn = 5000\np = .9\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5000   # sample size\np <- 0.9  # population proportion\nalpha <- .1\n\ngenerate_samp_prop <- function(n,p){\n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  \n  #create lower and upper bound with 90% CI\n  lb <- phat - 1.645 *sqrt(phat*(1-phat)/n)\n  ub <- phat + 1.645 *sqrt(phat*(1-phat)/n)\n  \n  \n  prop_df <- tibble(phat,lb,ub)\n  return(prop_df)\n}\n\ngenerate_samp_prop(n,p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1 0.905 0.898 0.912\n```\n:::\n\n```{.r .cell-code}\n#How many CI's we want\nn_sim <- 1000\n\nprop_ci_df <- map(1:n_sim, \\(i) generate_samp_prop(n,p)) |> \n  bind_rows()\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 3\n    phat    lb    ub\n   <dbl> <dbl> <dbl>\n 1 0.901 0.894 0.908\n 2 0.897 0.890 0.904\n 3 0.892 0.885 0.899\n 4 0.9   0.893 0.907\n 5 0.896 0.889 0.903\n 6 0.896 0.889 0.903\n 7 0.899 0.892 0.906\n 8 0.896 0.889 0.903\n 9 0.896 0.888 0.903\n10 0.900 0.893 0.907\n# ℹ 990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1    0.0139           0.9\n```\n:::\n:::\n\n\n\nn = 100\np = .9\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100   # sample size\np <- .9  # population proportion\nalpha <- .1\n\ngenerate_samp_prop <- function(n,p){\n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  \n  #create lower and upper bound with 90% CI\n   lb <- phat - 1.645 *sqrt(phat*(1-phat)/n)\n   ub <- phat + 1.645 *sqrt(phat*(1-phat)/n)\n  \n\n  prop_df <- tibble(phat,lb,ub)\n  return(prop_df)\n}\n\ngenerate_samp_prop(n,p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1  0.87 0.815 0.925\n```\n:::\n\n```{.r .cell-code}\n#How many CI's we want\nn_sim <- 1000\n\nprop_ci_df <- map(1:n_sim, \\(i) generate_samp_prop(n,p)) |> \n  bind_rows()\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 3\n    phat    lb    ub\n   <dbl> <dbl> <dbl>\n 1  0.94 0.901 0.979\n 2  0.93 0.888 0.972\n 3  0.91 0.863 0.957\n 4  0.89 0.839 0.941\n 5  0.91 0.863 0.957\n 6  0.91 0.863 0.957\n 7  0.9  0.851 0.949\n 8  0.92 0.875 0.965\n 9  0.92 0.875 0.965\n10  0.88 0.827 0.933\n# ℹ 990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1    0.0974         0.853\n```\n:::\n:::\n\n\n\n\nn = 5\np = .9\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5   # sample size\np <- 0.9  # population proportion\nalpha <- .1\n\ngenerate_samp_prop <- function(n,p){\n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  \n  #create lower and upper bound with 90% CI\n  lb <- phat - 1.645 *sqrt(phat*(1-phat)/n)\n  ub <- phat + 1.645 *sqrt(phat*(1-phat)/n)\n  \n  \n  prop_df <- tibble(phat,lb,ub)\n  return(prop_df)\n}\n\ngenerate_samp_prop(n,p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1     1     1     1\n```\n:::\n\n```{.r .cell-code}\n#How many CI's we want\nn_sim <- 1000\n\nprop_ci_df <- map(1:n_sim, \\(i) generate_samp_prop(n,p)) |> \n  bind_rows()\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 3\n    phat    lb    ub\n   <dbl> <dbl> <dbl>\n 1   1   1     1    \n 2   0.8 0.506 1.09 \n 3   1   1     1    \n 4   1   1     1    \n 5   0.8 0.506 1.09 \n 6   1   1     1    \n 7   0.8 0.506 1.09 \n 8   0.6 0.240 0.960\n 9   1   1     1    \n10   1   1     1    \n# ℹ 990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.264         0.418\n```\n:::\n:::\n\n\n\n$(n = 5000, p = .9):$  \n$np = 5000(.9) = 4500 > 10$: Assumption holds.  \n$n(1-p) = 5000(1-.9) = 500 > 10$: Assumption holds.  \n\n$(n = 100, p = .9):$  \n$np = 100(.9) = 90 >10$: Assumption holds.  \n$n(1-p) = 100(1-.9) = 10 = 10$: Assumption is equal to 10, so doesn't hold.  \n\n$(n = 5, p = .9):$  \n$np = 5(.9) = 4.5 < 10$: Assumption doesn't hold.  \n$n(1-p) = 5(1-.9) = .5 < 10$: Assumption doesn't hold.  \n\n\n$(n = 5000, p = .5):$  \n$np = 5000(.5) = 2500 > 10$: Assumption holds.  \n$n(1-p) = 5000(1-.5) = 2500 > 10$: Assumption holds.  \n\n$(n = 100, p = .5):$  \n$np = 100(.5) = 50 >10$: Assumption holds.  \n$n(1-p) = 100(1-.5) = 50 > 10$: Assumption holds.  \n\n$(n = 5, p = .5):$  \n$np = 5(.9) = 2.5 < 5$: Assumption doesn't hold.  \n$n(1-p) = 5(1-.5) = 5 < 10$: Assumption doesn't hold.  \n\n\n\n\n\n\n\n\n\n|  |         | $n = 5$ | $n = 100$  | $n = 5000$ |\n|:----:|:-----------------:|:-------------:|:------------:|:------------:|\n| $p = .9$   | Coverage Rate       |     .378    |   .872     |    .895      |\n| $p = .5$   | Coverage Rate       |     .631   |   .915    |     .902      |\n|    |                     |               |              |              |\n| $p = .9$    | Average Width        |   .238   |     .097    |     .014      |\n| $p = .5$    | Average Width        |   .639    |    .162   |      .023      |\n\n\n: Table of Results {.striped .hover}\n\n\n\n\nOverall, when $n=5000$, no matter the probabilities that I used, the \"large enough\" assumptions holds. When $n=100$ and the probability is $.5$, then the assumptions hold but when $p=.9$ the assumption that $n(1-p)>10$ doesn't hold. The assumptions never hold when $n=5$. \n\nAs $n$ increases in size, the coverage rates increase towards the confidence level and the average widths of the confidence intervals decrease. As $n$ gets quite large, say $5000$, the coverage rate is very close to our confidence interval, in this case $90%$. This is because as $n$ gets large, the mean of the simulation gets closer to the true mean and so the average width of the interval gets smaller. For the three groups where the assumptions do not hold, the coverage rates are not very close to the confidence level. For the other three groups, the rates are clsoe to the 90% confidence interval.  \n\nIt can be concluded that for small sample sizes where the assumptions don't hold, the normal approximation of the binomial distribution does not do a good job. We are getting much smaller coverages than we expect for small sample sizes. For large values of $n$ and especially for extremely large values, the normal approximation holds, shown by getting the coverage rate extremly close to the confidence level.\n\n---\ntitle: \"03 - Confidence Intervals\"\n---\n\n\nMini Project 3: Confidence Intervals\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}